import numpy
cimport numpy
from libc.math cimport sqrt as c_sqrt
from libc.math cimport sin as c_sin
from libc.math cimport acos as c_acos
from libc.math cimport asin as c_asin

cdef class cVector3D:
    def __cinit__(self, double x, double y, double z):
        self.xyz[0] = x
        self.xyz[1] = y
        self.xyz[2] = z
        self.index = -1

    def __init__(self, double x, double y, double z):
        self.xyz[0] = x
        self.xyz[1] = y
        self.xyz[2] = z

    property x:
        def __get__(self):
            return self.xyz[0]
        def __set__(self, double value):
            self.xyz[0] = value

    property y:
        def __get__(self):
            return self.xyz[1]
        def __set__(self, double value):
            self.xyz[1] = value

    property z:
        def __get__(self):
            return self.xyz[2]
        def __set__(self, double value):
            self.xyz[2] = value

    def __repr__(self):
        return str([self.x, self.y, self.z])

    def __iter__(self):
        for item in [self.x, self.y, self.z]:
            yield item

    def __add__(cVector3D self, cVector3D other):
        return self._c_add(other)

    def __sub__(cVector3D self, cVector3D other):
        return self._c_sub(other)

    def __richcmp__(cVector3D self, cVector3D other, int op):
        if op == 2:
            return self.x == other.x and \
                   self.y == other.y and \
                   self.z == other.z
        else:
            return NotImplemented

    def vec_scale(cVector3D self, double factor):
        return self._c_vec_scale(factor)

    def dot(cVector3D self, cVector3D other):
        return self._c_dot(other)

    def cross(cVector3D self, cVector3D other, cVector3D origin=None):
        if origin is None:
            return self._c_cross(other)
        else:
            self._c_sub(origin)
            return self._c_cross(other._c_sub(origin))

    def l2_norm(cVector3D self):
        return self._c_l2_norm()

    def copy(cVector3D self):
        return self._c_copy()

    def to_numpy_array(self):
        return numpy.array(self.xyz)

    def vec_mat_mul(self, m):
        return self._c_vec_mat_mul(m)

    def rotated(self, angle, axis):
        return self._c_rotated(angle, axis)

    def __getitem__(self, item):
        return self.xyz[item]

    def angle(self,other):
        return self._c_angle(other)

    def normalise(self):
        return self._c_normalise()

    cdef cVector3D _c_add(cVector3D self, cVector3D other):
        cdef cVector3D r = cVector3D(0, 0, 0)
        r.xyz[0] = self.xyz[0] + other.xyz[0]
        r.xyz[1] = self.xyz[1] + other.xyz[1]
        r.xyz[2] = self.xyz[2] + other.xyz[2]
        return r

    cdef cVector3D _c_sub(cVector3D self, cVector3D other):
        cdef cVector3D r = cVector3D(0, 0, 0)
        r.xyz[0] = self.xyz[0] - other.xyz[0]
        r.xyz[1] = self.xyz[1] - other.xyz[1]
        r.xyz[2] = self.xyz[2] - other.xyz[2]
        return r

    cdef cVector3D _c_vec_scale(cVector3D self, double factor):
        cdef cVector3D r = cVector3D(0, 0, 0)
        r.xyz[0] = self.xyz[0] * factor
        r.xyz[1] = self.xyz[1] * factor
        r.xyz[2] = self.xyz[2] * factor
        return r

    cdef double _c_dot(cVector3D self, cVector3D other):
        return self.xyz[0] * other.xyz[0] + \
               self.xyz[1] * other.xyz[1] + \
               self.xyz[2] * other.xyz[2]

    cdef double _c_l2_norm(cVector3D self):
        return c_sqrt(self.xyz[0] * self.xyz[0] + self.xyz[1] * self.xyz[1] + self.xyz[2] * self.xyz[2])

    cdef cVector3D _c_cross(cVector3D self, cVector3D other):
        cdef cVector3D r = cVector3D(0, 0, 0)
        cdef double x, y, z
        x = self.xyz[1] * other.xyz[2] - self.xyz[2] * other.xyz[1]
        y = self.xyz[2] * other.xyz[0] - self.xyz[0] * other.xyz[2]
        z = self.xyz[0] * other.xyz[1] - self.xyz[1] * other.xyz[0]
        r.xyz[0] = x
        r.xyz[1] = y
        r.xyz[2] = z
        return r

    cdef cVector3D _c_copy(cVector3D self):
        return cVector3D(self.xyz[0], self.xyz[1], self.xyz[2])

    cdef cVector3D _c_vec_mat_mul(cVector3D self, cMatrix3D m):
        cdef double x, y, z
        x = self.xyz[0] * m.get(0, 0) + self.xyz[1] * m.get(1, 0) + self.xyz[2] * m.get(2, 0)
        y = self.xyz[0] * m.get(0, 1) + self.xyz[1] * m.get(1, 1) + self.xyz[2] * m.get(2, 1)
        z = self.xyz[0] * m.get(0, 2) + self.xyz[1] * m.get(1, 2) + self.xyz[2] * m.get(2, 2)
        self.xyz[0] = x
        self.xyz[1] = y
        self.xyz[2] = z
        return self

    cdef cVector3D _c_rotated(cVector3D self, double angle, cVector3D about):
        ''' Return a new Vector3D when vector3d_in is rotated about vector3d_about by angle
    
        This is an optimised version of the code. Generated by Mathematica.
    
        :param vector3d_in: Input vector that should be rotated
        :type vector3d_in: :class:`.Vector3D` or list or tuple of length 3
        :param angle: Angle to rotate by in radians
        :type angle: float
        :param vector3d_about: Vector about which the rotation occurs
        :type vector3d_about: :class:`.Vector3D` or list or tuple of length 3
        :return: Returns a vector in new direction
        :rtype: :class:`.Vector3D`
        '''
        cdef double t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30
        try:
            t1 = about.xyz[0]
            t2 = t1 * t1
            t3 = about.xyz[1]
            t4 = t3 * t3
            t5 = about.xyz[2]
            t6 = t5 * t5
            t7 = t2 + t4 + t6
            t8 = 2.5e-1 / t7
            t12 = 5.e-1 * angle
            t13 = c_sin(t12)
            t14 = t13 * t13
            t15 = 1.0 / t14
            t9 = 4. * t14
            t10 = c_sin(angle)
            t16 = self.xyz[0]
            t19 = self.xyz[1]
            t21 = self.xyz[2]
            t18 = t7 ** 5.e-1
            t30 = t19 * t3
            self.xyz[0] = (t10 * (t10 * t7 * t15 * t16 - 4. * t18 * (-t21 * t3 + t19 * t5)) + t9 * (
            t16 * t2 + 2.e0 * t1 * (t30 + t21 * t5) - t16 * (t4 + t6))) * t8
            self.xyz[1] = (t9 * (-t19 * t2 + 2.e0 * t1 * t16 * t3 + t19 * (t4 - t6) + 2. * t21 * t3 * t5) + t10 * (
            t10 * t7 * t15 * t19 + 4.e0 * t18 * (-t1 * t21 + t16 * t5))) * t8
            self.xyz[2] = (t10 * (t10 * t7 * t15 * t21 - 4. * t18 * (-t1 * t19 + t16 * t3)) + t9 * (
            -t21 * (t2 + t4 - t6) + 2.e0 * (t1 * t16 + t30) * t5)) * t8
        except ZeroDivisionError:
            pass
        return self

    cdef double _c_angle(cVector3D self, cVector3D other):
        cdef double dot_product
        cdef cVector3D norm1,norm2
        norm1 = self._c_normalise()
        norm2 = other._c_normalise()
        dot_product = norm1._c_dot(norm2)
        return c_acos(dot_product) * 57.2958 #radian to degree


    cdef cVector3D _c_normalise(cVector3D self):
        cdef double norm
        norm = self._c_l2_norm()
        return self._c_vec_scale(1.0/norm)